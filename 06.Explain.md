# Explain 性能分析

## 是什么（执行计划）

使用 EXPLAIN 关键字可以模拟优化器执行 SQL 查询语句，从而知道 MySL 是如何处理你的 SQL 语句的。
分析你的查询语句或是表结构的性能瓶颈

## 能干什么

1. 表的读取顺序
2. 数据读取操作的操作类型
3. 哪些索引可以使用
4. 哪些索引被实际使用
5. 表之间的引用
6. 每张表有多少行被优化器查询

## 怎么玩

- Explain + SQL 语句
- 执行计划包含的信息
  id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra

## 各字段解释

1. id - select 查询的序列号，包含一组数字，表示查询中执行 select 子句或操作表的顺序

- id 相同：执行顺序由上至下
- id 不同：如果是子查询，id 的序号会递增，id 值越大，优先级越高，越先被执行。
- id 相同和不同，同时存在：id 如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id 值越大，优先级越高，越先执行；

2. select_type

- 有哪些
  SIMPLE, PRIMARY, SUBQUERY, DERIVED, UNION, UNION RESULT

- 查询的类型，主要是用于去呗： 普通查询，联合查询，子查询等的复杂查询。

  1. SIMPLE - 简单的 select 查询，查询中不包含子查询或者 UNION
  2. PRIMARY - 查询中若包含任何复杂的子部分，最外层查询被标记。
  3. SUBQUERY - 在 select 或 where 雷彪中包含子查询
  4. DERIVED - 在 FROM 列表中包含的子查询被标记为 DERIVED(衍生)，MySQL 会递归执行这些子查询，把结果放在临时表里。
  5. UNION - 若第二个 SELECT 出现在 UNION 之后，则被标记为 UNION;若 UNION 包含在 FROM 子句的子查询中，外层 SELECT 将被标记为：DERIVED.
  6. UNION RESULT - 从 UNION 表获取结果的 SELECT

3. table - 显示这一行的数据是关于哪张表的；

4. type 类型：System | const | eq_ref | ref | range | index | all

- 访问类型排列，显示查询使用了何种类型；
- 从最好到最差依次是：
  system > const > eq_ref > ref > range > index > ALL(是全表扫描)
- 一般来说，得保证查询至少达到 range 级别，最好能达到 ref.

  1. system: 表只有一行记录（等于系统表），这是 const 类型的特例，平时不会出现，可以忽略不计

  2. const: 表示通过索引一次就找到了。const 用于比较 primary key 或者 unique 索引。因为只匹配
     一行数据，所以很快。如将主键置于 where 列表中，MySQL 就能将该查询转换为一个常量。

  3. eq_ref: 唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描。

  4. ref: 非唯一性索引扫描，返回匹配某个单独值的所有性。本质上也是一种索引访问，它返回所有匹配某个值的行。
     然而，它可能会找到多个复合条件的行，所以它应该属于查找和扫描的混合体。
  5. range: 只检索给定范围的行，使用一个索引来选择行。key 列显示使用了那个索引，一般就是在你的 where 语句中
     出现了 bwtween, <, >, <=, >= 等范围查询. 这种范围扫描索引的效率会比全表扫描高。因为它只需要开始于索引
     的某一点，而结束的另一点，不用扫描全部索引。
  6. index: Full Index Scan，index 与 ALL 区别为 index 类型，只遍历索引树。这通常比 ALL 快，因为索引文件
     通常比数据文件小。（也就是说虽然 all 和 index 都是读全表），但是 index 是从索引中读取的，而 all 是从硬盘中读取的。
  7. ALL: 全表扫描。

5. possible_keys： 显示可能应用在这张表中的索引，一个或多个。

   - 查询设计到的字段若存在索引，则该索引将被列出，但不一定被查询实际使用

6. key： 实际使用的索引。如果为 NULL,则没有使用索引。

   - 查询中若使用了覆盖索引，则该索引仅出现在 key 列表中
     > 查询字段，正好对应索引字段，且顺序一致。

7. key_len： 表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好。

   - ke_len 显示的值为索引字段的最大可能长度。并非实际使用长度。
   - 即 key_len 是根据表定义计算而得，不是通过表内检索出的。

8. ref： 显示索引的哪一列被使用了，如果可能得话，是一个常数，哪些列或常量被用于查找索引列上的值。
9. rows：根据表统计信息及索引选用情况，大致估算出找到所需的记录，所需要读取的行数。
10. Extra
    1. Using filesort: 说明 mysql 会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。
       MySQL 中无法利用索引完成的排序操作称为 ”文件排序“。
    2. Using temporary: 使用了临时表保存中间结果，MySQL 在对查询结果排序时，使用临时表。常见于排序 order by 和分组查询 group by.
    3. Using index: 表示相应的 select 操作中使用了覆盖索引（Covering Index),避免访问了表的数据行，效率不错！
       - 如果同时出现 using where,表名索引被用来执行索引键值的查找；
       - 如果没有同时出现 using where,表明索引用来读取数据而非执行查找动作；

## 覆盖索引(Covering Index):

- 方式一： 就是 select 的数据列只用从索引中就能取得，不必读取数据行，MySQL 可以利用索引返回 select 列表中的字段，而不必
  根据索引再次读取数据文件，换句话说 - 查询列要被所建的索引覆盖；
  > 1. 建立索引是复合索引，三个字段 col1,col2,col3;
  > 2. 没有使用 select \*,也没有写 select col1,...col9,...col10
  > 3. 也就是你建立的复合字段的 3 个索引，刚好查的也是这 3 个字段中的字段；且顺序于建立时是一致匹配的
