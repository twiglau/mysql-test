# 索引优化

## 分析

1. 性能下降 SQL 慢
2. 执行时间长
3. 等待时间长

---

- 查询语句写的不好
- 索引失效 【单值索引，复合索引】
- 关联查询太多 join (设计缺陷或不得已的需求)
- 服务器调优及各个参数设置（缓冲，线程数等）

```sh
# 单值索引
select * from user where name='xxx';
# 建立索引 - 单值索引
create index idx_user_name on user(name);
```

## 常见通用的 Join 查询

1. SQL 执行顺讯

- 手写

```sql
SELECT DISTINCT
     <select_list>
FROM
     <left_table> <join_type>
JOIN <right_table> ON <join_condition>
WHERE
     <where_condition>
GROUP BY
     <group_by_list>
HAVING
     <having_condition>
ORDER BY
     <order_by_condition>
LIMIT <limit_number>
```

- 机器读

```sql
1. FROM <left_table>
2. ON <join_condition>
3. <join_type> JOIN <right_table>
4. WHERE <where_condition>
5. GROUP BY <group_by_list>
6. HAVING <having_condition>
7. SELECT
8. DISTINCT <select_list>
9. ORDER BY <order_by_condition>
10. LIMIT <limit_number>
```

- 总结

```lua
SQL 解析
```

2. Join 图

```sql
-- 取A表： 完整
SELECT <select_list>
FROM TableA A
LEFT JOIN TableB B
ON A.key = B.key

-- 取A表: 除去与B的交集
SELECT <select_list>
FROM TableA A
LEFT JOIN TableB B
ON A.key = B.key
WHERE B.key IS NULL

-- 取A表和B表的 交集
SELECT <select_list>
FROM TableA A
INNER JOIN TableB B
ON A.key = B.key

-- 取B表；完整
SELECT <select_list>
FROM TableA A
RIGHT JOIN TableB B
ON A.key = B.key

-- 取B表：除去与A的交集
SELECT <select_list>
FROM TableA A
RIGHT JOIN TableB B
ON A.key = B.key
WHERE A.key IS NULL

-- 取B表和A表的 并集 - MySql 不支持这中语法
SELECT <select_list>
FROM TableA A
FULL OUTER JOIN TableB B
ON A.key = B.key

-- mysql
SELECT <select_list>
FROM TableA A
LEFT JOIN TableB B
ON A.key = B.key

UNION -- 去重

SELECT <select_list>
FROM TableA A
RIGHT JOIN TableB B
ON A.key = B.key


-- 取A表和B表：除去交集的 剩余数据
SELECT <select_list>
FROM TableA A
FULL OUTER JOIN TableB B
ON A.key = B.key
WHERE A.key IS NULL OR B.key IS NULL

-- mysql
SELECT <select_list>
FROM TableA A
LEFT JOIN TableB B
ON A.key = B.key
WHERE B.key IS NULL

UNION -- 去重

SELECT <select_list>
FROM TableA A
RIGHT JOIN TableB B
ON A.key = B.key
WHERE A.key IS NULL
```
