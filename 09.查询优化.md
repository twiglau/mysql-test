# 查询优化

1. SQL,跑至少 1 天，看看生产的慢 SQL 情况；
2. 开启慢查询日志，设置阈值，比如超 5s 的，就是慢 SQL,并将它抓取出来；
3. EXPLAIN + 慢 SQL 分析；
4. SHOW PROFILE 查询 SQL 在 Mysql 服务器里面的执行细节和生命周期情况；
5. SQL 数据库服务器的参数调优；

## 永远小表驱动大表 - 类似嵌套循环(Nested Loop)

- 小的数据集驱动大的数据集；原理（RBO）

```js
// 类似于
for (const a = 0; a < 5; a++) {
  for (const b = 0; b < 1000; b++) {
    console.log(a * b);
  }
}
```

```sql
SELECT * FROM A WHERE id IN (SELECT id FROM B)

-- 等价于：
-- for select id from B
-- for select * from A where A.id = B.id

-- 当B表的数据集必须小于A表的数据集时，用 IN 优于 EXISTS.

SELECT * FROM A WHERE EXISTS (SELECT 1 FROM B WHERE B.id = A.id)

-- 等价于：
-- for select * from A
-- for select * from B where B.id = A.id

-- 当A表的数据集小于B表的数据集时，用 EXISTS 优于 IN.

-- 注意：A表与B表的ID字段应建立索引。
```

- EXISTS:

1. 可以理解为：将 A 查询的数据，放到子查询 B 中做条件验证，根据验证结果（TRUE 或 FALSE),来决定主查询 A 的数据结果是否得以保留。

```sql
-- IN 写法
SELECT * FROM tbl_emp e WHERE e.deptId IN (SELECT id FROM tbl_dept d);
-- EXISTS 写法
SELECT * FROM tbl_emp e WHERE EXISTS (SELECT 1 FROM tbl_dept d WHERE d.id = e.deptId);
```

2. EXISTS(subquery) 只返回 TRUE 或 FALSE,因此子查询中的 SELECT \* 也可以是 SELECT 1 或 SELECT 'X',
   就是实际执行时，会忽略 SELECT 清单，因此没有区别。
3. EXISTS 子查询的实际执行过程，可能经过了优化，而不是我们理解上的逐条对比，如果担忧效率问题，可进行实际检验
   以确定是否有效率问题。
4. EXISTS 子查询往往也可以用条件表达式，其他子查询或者 JOIN 来替代，何种最优，需要具体问题具体分析。

## Order By 关键字优化

```sql
CREATE TABLE tbl_a(
#id int primary key not null auto_increment,
age INT,
birth TIMESTAMP NOT NULL
);
INSERT INTO tbl_a(age,birth) VALUES(22,NOW());
INSERT INTO tbl_a(age,birth) VALUES(23,NOW());
INSERT INTO tbl_a(age,birth) VALUES(24,NOW());

CREATE INDEX idx_tbl_a_ageBirth ON tbl_a(age,birth);

SELECT * FROM tbl_a;
```

- ORDER BY 子句，尽量使用 Index 方式排序，避免使用 FileSort 方式排序；
- 尽可能在索引列上完成排序，遵照索引建立时的 最佳左前缀；

1. SQL 支持两种方式的排序，FileSort 和 Index,Index 效率高，指的是 MySQL 扫描索引本身完成排序。
2. ORDER BY 满足两种情况，会使用 Index 方式排序：
   > 1. ORDER BY 语句使用索引最左前列
   > 2. 使用 WHERE 子句与 ORDER BY 子句条件列组合满足索引最左前列

```sql
SELECT * FROM tbl_a WHERE age > 20 ORDER BY age;
SELECT * FROM tbl_a WHERE age > 20 ORDER BY age,birth;
-- 产生FileSort
SELECT * FROM tbl_a WHERE age > 20 ORDER BY birth;
SELECT * FROM tbl_a WHERE age > 20 ORDER BY birth,age;
SELECT * FROM tbl_a ORDER BY age ASC,birth DESC;
```

- 如果不在索引列上，FileSort 有两种算法：MySql 就要启动双路排序和单路排序；

1. 双路排序
   > 1. MySQL 4.1 之前是使用双路排序，字面意思就是两次扫描磁盘，最终得到数据；读取行指针和 ORDER BY 列，对他们进行排序，然后扫描已经排序号的列表，按照列表中的值重新从列表中读取对应的数据，进行输出；
   > 2. 从磁盘取排序字段，在 buffer 进行排序，再从磁盘取其他字段；
   > 3. 取一批数据，要对磁盘进行了两次扫描，众所周知，I\O 是很耗时的，在 MySQL4.1 之后，出现了第二种改进的算法 - 单路排序。
2. 单路排序
   > 1. 从磁盘读取查询需要的所有列，按照 order by 列在 buffer 对它们进行排序，然后扫描排序后的列表进行输出，它的效率更快一些，避免了第二次读取数据。并且把随机 IO 变成了顺序 IO,但是它会使用更多的空间，因为它把每一行都保存在内存中了。

- 结论及引申出的问题

1. 由于单路是后出的，总体而言好过双路
2. 但是用单路有问题
   > 1. 在 sort_buffer 中，方法 B 比方法 A 要多占用很多空间，因为方法 B 是把所有字段都取出，所以有可能取出的数据的总大小超出了
   >    sort_buffer 的容量，导致每次智能取 sort_buffer 容量大小的数据，进行排序（创建 tmp 文件，多列合并），拍完再取 sort_buffer
   >    容量大小，再排序...,从而多次进行 I/O.
   > 2. 本来想省一次 I/O 操作，反而导致了大量的 I/O 操作，反而得不偿失；

- 优化策略

1. 增大 sort_buffer_size 参数的设置；
2. 增大 max_length_for_sort_data 参数的设置；

- 如何提高 ORDER BY 的速度

1.  ORDER BY 时，SELECT \* 是一个大忌。正确做法是，Query 只需要的字段。这点非常重要，在这里的影响是：
    > 1. 当 Query 的字段大小总和小于 max_length_for_sort_data,而且排序字段不是 TEXT|BLOB 类型时，会用改进后的算法 -- 单路排序，否则用
         老算法 -- 多列排序。
    > 2. 两种算法的数据都有可能超出 sort_buffer 的容量，超出之后，会创建 tmp 文件进行合并排序，导致多次 I/O,但是用单路排序算法的风险会
         更大一些，所以要提高 sort_buffer_size.
2.  尝试提高 sort_buffer_size
    > 不管用那种算法，提高这个参数都会提高效率，当然，要根据系统的能力去提高，因为这个参数是针对每个进程的；
3.  尝试提高 max_length_for_sort_data
    > 提高这个参数，会增加用改进算法的概率。但是如果设置的太高，数据总容量超出 sort_buffer_size 的概率就增大，明显症状
    > 是高的磁盘 I/O 活动和低效的处理器使用率。

## 为排序使用索引

- MySQL 两种排序方式：文件排序或扫描有序索引排序
- MySQL 能为排序与查询使用相同的索引

```sql
KEY a_b_c(a,b,c)

order by 能使用索引 最左前缀
- ORDRE BY a;
- ORDRE BY a,b;
- ORDRE BY a,b,c;
- ORDRE BY a DESC,b DESC,c DESC;


如果WHERE使用索引的最左前缀定义为常量，则order by能使用索引
- WHERE a = const ORDER BY b, c
- WHERE a = const AND b = const ORDER BY c
- WHERE a = const ORDER BY b, c
- WHERE a = const AND b > const ORDER BY b, c
不能使用索引进行排序
- ORDER BY a ASC, b DESC, c DESC -- 排序不一致
- WHERE g = const ORDER BY b, c -- /丟失a索引*/
- WHERE a = const ORDER BY c  -- /丢失b索引 /
- WHERE a = const ORDER BY a, d -- d不是索引的一部分 /
- WHERE a in (...) ORDER BY b, c -- 对于排序来说，多个相等条件也是范围查询
```

## Group By

1. group by 实质是先排序，后进行分组。遵照索引建的最佳左前缀
2. 当无法使用索引列，增大 max_length_for_sort_data 参数的设置 + 增大 sort_buffer_size 参数的设置
3. where 高于 having,能写在 where 限定的条件，就不要去 having 限定了。
