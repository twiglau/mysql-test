# 行锁

- 偏向 InnoDB 存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。
- InnoDB 与 MyISAM 的最大不同有两点： 一是支持事务(TRANSACTION);二是采用了行级锁。

## 行锁支持事务

- 事务(Transaction)及其 ACID 属性

1. 事务是有一组 SQL 语句组成的逻辑处理单元。事务具有以下 4 个属性，通常简称为事务的 ACID 属性。
   > 1. 原子性(Atomicity): 事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。
   > 2. 一致性(Consistent): 在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以保持数据的完整性；事务结果时，所有的内部数据结果（如 B 数索引或双向链表）也都必须是正确的。
   > 3. 隔离性(Isolation): 数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的。
   > 4. 持久性(Durable): 事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。

- 并发事务处理带来的问题

1. 更新丢失（Lost Update)

当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题一一最后的更新覆盖了由其他事务所做的更新。

例如，两个程序员修改同一 java 文件。每程序员独立地更改其副本，然后保存更改后的副本，这样就覆盖了原始文档。最后保存其更改副本的编辑人员覆盖前一个程序员所做的更改。

如果在一个程序员完成并提交事务之前，另一个程序员不能访问同一文件，则可避免此问题。

2. 脏读（Dirty Reads)

一个事务正在对一条记录做修改，在这个事务完成并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做”脏读”。
一句话：事务 A 读取到了事务 B 已修改但尚未提交的的数据，还在这个数据基础上做了操作。此时，如果 B 事务回滚，A 读取的数据无效，不符合一致性要求。

3. 不可重复读（Non-Repeatable Reads)

一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了！这种现象就叫做“不可重复读”。

一句话：事务 A 读取到了事务 B 已经提交的修改数据，不符合隔离性

4. 幻读（Phantom Reads)

一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”。
一句话：事务 A 读取到了事务 B 体提交的新增数据，不符合隔离性。

多说一句：幻读和脏读有点类似，
脏读是事务 B 里面修改了数据
幻读是事务 B 里面新增了数据。

- 事务隔离级别

脏读”、“不可重复读”和“幻读”，其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决。

```lua
读教据一致性及允许的并发副作用(隔离级别)           读敳据一致性                  脏读     不可車复读    幻读

未提交读（Read uncommitted）       最低级別，只能保证不读取物理上损坏的数据       是         是         是
已提交度（Read committed）                       语句级                     否         是         是
可重复读（Repeatable read）                      事务级                     否         否         是
可序列化（Serializable）                    量高级别，事务级                  否         否         否

```

1. 数据库的事务隔离越严格，并发副作用越小，但付出的代价也就越大，因为事务隔离实质上就是使事务在一定程度上“串行化”进行，这显然与“并发”是矛盾的。同时，不同的应用对读一致性和事务隔离程度的要求也是不同的，比如许多应用对“不可重复读”和“幻读”并不敏感，可能更关心数据并发访问的能力。

2. 常看当前数据库的事务隔离级别：

```sql
show variables like 'tx_isolation';
```

## 实例分析

1. 建表 SQL

```sql
create table test_innodb_lock(
 a int(11),
 b varchar(16)
)engine=innodb;

insert into test_innodb_lock values(1,'b2');
insert into test_innodb_lock values(3,'3');
insert into test_innodb_lock values(4,'4000');
insert into test_innodb_lock values(5,'5000');
insert into test_innodb_lock values(6,'6000');
insert into test_innodb_lock values(7,'7000');
insert into test_innodb_lock values(8,'8000');
insert into test_innodb_lock values(9,'9000');
insert into test_innodb_lock values(1,'b1');

create index test_innodb_a_ind on test_ _innodb_lock(a);
create index test_innodb_lock_b_ind on test_innodb_lock(b);
```

2. 行锁定基本演示

````lua
                    Session_1                        Session_2
1.               set autocommit=0;                  set autocommit=0;

2.            更新但是不提交，没有手写 commit.           Session_2被阻塞，只能等待
                 ```sql                               ```sql
           update test_innodb_lock              update test_innobd_lock
           set b = 'b1' where a = 1;            set b = 'b2' where a =1;
                  ```                                   ```
3.               提交更新                              解除阻塞，更新正常进行
                  ```sql                              ```sql
                  commit;                        Query OK, o rows affected (37.00 sec)
                  ```                                 ```
````

3. 无索引行锁升级为表锁

```lua
                      Session-1                    Session-2
                  set autocommit=0;                set autocommit=0;

1.               update test_innodb_lock           update test_innodb_lock
                 set a=41 where b=4000;            set b='9002' where a=9;
                --【b 索引，发生隐式转化，索引失效】成功    --阻塞了

2.                     commit;                     "Query OK, row effected (29.50 sec)" 花费了 约30s

```

4. 间隙锁危害

```lua
                      Session-1                    Session-2
                  set autocommit=0;                set autocommit=0;

1.               update test_innodb_lock           insert into test_innodb_lock
                 set b='0629' where a>1 and a<6;   values(2, '2000');
                --注意：id=2记录，并不存在，但是        --session-2 插入语句也被阻塞了

2.                     commit;                     "Query OK, row effected (13.50 sec)" 花费了 约13s

```

- 什么是间隙锁
  当我们用范围条件而不是相等条件检索数据，请请求共享或排他锁时，InnoDB 会给符合条件的已有数据记录的索引项加锁；
  对于键值在条件范围内，但并不存在的记录，叫做 “间隙”(GAP).

- 危害
  因为 Query 执行过程中通过范围查找的话，他会锁定整个范围内所有的索引键值，即使这个键值并不存在。
  间隙锁有一个比较致命的弱点，就是当锁定一个范围键值之后，即使某些不存在的键值，也会被无辜的锁定，而造成在锁定的时候
  无法插入锁定键值范围内的任何数据。在某些场景下，这可能会对性能造成很大的危害。

5. 如何锁定一行: 手工为某条记录上锁

```lua
                      Session-1                       Session-2

0.                      begin;
1.               select * from test_innodb_lock       update test_innodb_lock
                 where a=8 for update;                set b='8001' where a=8;
                --注意：select xxx.. for update       --session-2 插入语句也被阻塞了
                --     锁定某一行后，其他的操作会被
                --     阻塞，知道锁定行的会话提交 commit
2.                     commit;                     "Query OK, row effected (13.50 sec)" 花费了 约13s

```

## 总结

- Innodb 存储引擎由于实现了行级锁定。虽然在锁定机制的实现方面所带来的性能损耗，可能比表级锁定会要更高一些。
  但是在整体并发处理能力方面要远远优于 MyISAM 的表级锁定的。当系统并发量较高的时候，Innodb 的整体性能和 MyISAM
  相比就会有比较明显的优势了。

- 但是，Innodb 的行级锁定同样也有其脆弱的一面，当我们使用不当的时候，可能会让 Innodb 的整体性能表现不仅不能比 MyISAM
  高，甚至可能会更差。

- 如何分析行锁定
  > 通过检查 InnoDB_row_lock 状态变量，来分析系统上的行锁的争夺情况。

```sql
show status like 'innodb_row_lock%';
```

1. Innodb_row_lock_current_waits: 当前正在等待锁定的数量；
2. Innodb_row_lock_time: 从系统启动到现在锁定总时间长度；

## 优化建议

1. 尽可能让所有数据检查都通过索引来完成，避免无索引行锁升级为表锁。
2. 合理设计索引，尽量缩小锁的范围。
3. 尽可能较少检索条件，避免间隙锁。
4. 尽量控制事务大小，减少锁定资源量和时间长度。
5. 尽可能低级别事务隔离。
