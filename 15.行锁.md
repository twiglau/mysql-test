# 行锁

- 偏向 InnoDB 存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。
- InnoDB 与 MyISAM 的最大不同有两点： 一是支持事务(TRANSACTION);二是采用了行级锁。

## 行锁支持事务

- 事务(Transaction)及其 ACID 属性

1. 事务是有一组 SQL 语句组成的逻辑处理单元。事务具有以下 4 个属性，通常简称为事务的 ACID 属性。
   > 1. 原子性(Atomicity): 事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。
   > 2. 一致性(Consistent): 在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以保持数据的完整性；事务结果时，所有的内部数据结果（如 B 数索引或双向链表）也都必须是正确的。
   > 3. 隔离性(Isolation): 数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的。
   > 4. 持久性(Durable): 事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。

- 并发事务处理带来的问题

1. 更新丢失（Lost Update)

当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题一一最后的更新覆盖了由其他事务所做的更新。

例如，两个程序员修改同一 java 文件。每程序员独立地更改其副本，然后保存更改后的副本，这样就覆盖了原始文档。最后保存其更改副本的编辑人员覆盖前一个程序员所做的更改。

如果在一个程序员完成并提交事务之前，另一个程序员不能访问同一文件，则可避免此问题。

2. 脏读（Dirty Reads)

一个事务正在对一条记录做修改，在这个事务完成并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做”脏读”。
一句话：事务 A 读取到了事务 B 已修改但尚未提交的的数据，还在这个数据基础上做了操作。此时，如果 B 事务回滚，A 读取的数据无效，不符合一致性要求。

3. 不可重复读（Non-Repeatable Reads)

一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了！这种现象就叫做“不可重复读”。

一句话：事务 A 读取到了事务 B 已经提交的修改数据，不符合隔离性

4. 幻读（Phantom Reads)

一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”。
一句话：事务 A 读取到了事务 B 体提交的新增数据，不符合隔离性。

多说一句：幻读和脏读有点类似，
脏读是事务 B 里面修改了数据
幻读是事务 B 里面新增了数据。

- 事务隔离级别

脏读”、“不可重复读”和“幻读”，其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决。

```lua
读教据一致性及允许的并发副作用(隔离级别)           读敳据一致性                  脏读     不可車复读    幻读

未提交读（Read uncommitted）       最低级別，只能保证不读取物理上损坏的数据       是         是         是
已提交度（Read committed）                       语句级                     否         是         是
可重复读（Repeatable read）                      事务级                     否         否         是
可序列化（Serializable）                    量高级别，事务级                  否         否         否

```

1. 数据库的事务隔离越严格，并发副作用越小，但付出的代价也就越大，因为事务隔离实质上就是使事务在一定程度上“串行化”进行，这显然与“并发”是矛盾的。同时，不同的应用对读一致性和事务隔离程度的要求也是不同的，比如许多应用对“不可重复读”和“幻读”并不敏感，可能更关心数据并发访问的能力。

2. 常看当前数据库的事务隔离级别：

```sql
show variables like 'tx_isolation';
```

## 实例分析

1. 建表 SQL

```sql
create table test_innodb_lock(
 a int(11),
 b varchar(16)
)engine=innodb;

insert into test_innodb_lock values(1,'b2');
insert into test_innodb_lock values(3,'3');
insert into test_innodb_lock values(4,'4000');
insert into test_innodb_lock values(5,'5000');
insert into test_innodb_lock values(6,'6000');
insert into test_innodb_lock values(7,'7000');
insert into test_innodb_lock values(8,'8000');
insert into test_innodb_lock values(9,'9000');
insert into test_innodb_lock values(1,'b1');

create index test_innodb_a_ind on test_ _innodb_lock(a);
create index test_innodb_lock_b_ind on test_innodb_lock(b);
```

2. 行锁定基本演示

````lua
                    Session_1                        Session_2
1.               set autocommit=0;                  set autocommit=0;

2.            更新但是不提交，没有手写 commit.           Session_2被阻塞，只能等待
                 ```sql                               ```sql
           update test_innodb_lock              update test_innobd_lock
           set b = 'b1' where a = 1;            set b = 'b2' where a =1;
                  ```                                   ```
3.               提交更新                              解除阻塞，更新正常进行
                  ```sql                              ```sql
                  commit;                        Query OK, o rows affected (37.00 sec)
                  ```                                 ```
````

3. 无索引行锁升级为表锁
4. 间隙锁危害
5. 如何锁定一行
