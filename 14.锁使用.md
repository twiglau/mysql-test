# 锁机制

- 锁是计算机协调多个进程或线程，并发访问某一资源的机制。
- 在数据库中，除传统的计算资源(如 CPU,RAM,I/O 等)的争用之外，数据也是一种供许多用户共享的资源，
  如何保证数据并发访问的一致性，有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问
  性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。

## 例子：到淘宝上买一件商品，商品只有一件库存，这个时候如果还有另一个人买，那么如何解决是你买到，还是另外一个人买到的问题？

- 这里肯定要用的事务，我们先从库存表中取出物品数量，然后插入订单，付款后插入付款表信息。
- 然后更新商品数量。在这个过程中，使用锁可以对有限的资源进行保护，解决隔离和并发的矛盾。

## 锁的分类

1. 从对数据操作的类型（读、写）分类
   > 1. 读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会互相影响。
   > 2. 写锁（排它锁）：当前写操作没有完成前，它会阻断其他写锁和读锁。
2. 从对数据操作的粒度分类： 表锁，行锁
3. 三锁
   > 1. 表锁（偏读）
   > 2. 行锁（偏写）
   > 3. 页锁

## 表锁

- 偏向 MyISAM 存储引擎，开销小，加锁块；无死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低；
- 开销，加锁速度，死锁，粒度，并发性能，智能就具体应用的特点来说，那种锁更合适

```sql
-- 【表级锁分析--建表SQL】
create table mylock(
id int not null primary key auto_increment,
name varchar(20)
)engine myisam;

insert into mylock(name) values('a');
insert into mylock(name) values('b');
insert into mylock(name) values('c');
insert into mylock(name) values('d');
insert into mylock(name) values('e');


select * from mylock;

-- 手动增加表锁
lock table mylock read;
-- 查看表上加过的锁
show open tables;
-- 分析表锁定:可以通过检查 table_locks_waited 和 table_locks_immediate状态变量来分析系统上的表锁定；
show status like 'table%';

```

- 增加读锁；

```lua
        session_1                                 session_2

1. 获得表mylock的READ锁定                            连接终端
2. 当前session可以查询该表记录                        其他session也可以查询该表的记录
   `select * from mylock;`                        `select * from mylock;`
3. 当前session不能查询其他没有锁定的表                 其他session可以查询或者更新未锁定的表
   `select * from book;`(was not locked)          `update staffs set name='z2' where id = 1;`
4. 当前session中插入或更新锁定的表都会提示错误；         其他session插入或更新锁定表 会一直等待获得锁；
   `insert into mylock(name) values('a')`          `insert into mylock(name) values('e')`
5. 释放锁                                           Session2获得锁，插入操作完成；
   `unlock tables;`                                `insert into mylock(name) values('e')`
```

- 增加写锁；

```sql
lock table mylock write;
```

```lua
        session_1                                 session_2

1. 获得表mylock的READ锁定                            待session_1 开启写锁后，连接终端
2. 当前session对锁定表的查询+更新+插入操作都可以执行；    其他session对锁定表的查询被阻塞，需要等待锁被释放；
   `select * from mylock;`                        `select * from mylock;`
3. 释放锁                                           Session2获得锁，插入操作完成；
   `unlock tables;`                                `insert into mylock(name) values('e')`
```

### 总结

1.  MyISAM 在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行增删改操作前，会自动给涉及的表加写锁。
2.  MySQL 的表级锁有两种模式：
    > 1. 表共享读锁（Table Read Lock)
    > 2. 表独占写锁（Table Write Lock)
3.  对 MyISAM 表进行操作，会有以下情况：
    > 1. 对 MyISAM 表的读操作（加读锁），不会阻塞其他进程对同一表的读请求，但会阻塞对同一表的写请求。只有当读锁释放后，
         才会执行其他进程的写操作；
    > 2. 对 MyISAM 表的写操作（加写锁), 会阻塞其他进程对同一表的读和写操作，只有当写锁释放后，才会执行其他进程的读写操作。

### 分析表锁定

```sql
-- 分析表锁定:可以通过检查 table_locks_waited 和 table_locks_immediate状态变量来分析系统上的表锁定；
show status like 'table%';
```

- 这里有两个状态变量 记录 MySQL 内部表级锁定的情况

1. Table_locks_immediate: 产生表级锁定的次数，表示可以立即获取锁的查询次数，每立即获取锁值加 1；
2. Table_locks_waited: 出现表级锁定争用而发生等待的次数（不能立即获取锁的次数，每等待一次锁值加 1),此值高则说明存在着较为
   严重的表级锁争用情况；

- 此外，Myisam 的读写锁调度是 写优先，这也是 myisam 不适合做写为主表的引擎。因为写锁后，其他线程不能做任何操作，大量的更新会
  是查询很难得到锁，从而造成永远阻塞。
