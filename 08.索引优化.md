# 索引优化

```sql
CREATE TABLE staffs (
`id` INT PRIMARY KEY AUTO_INCREMENT,
`NAME` VARCHAR(24) NOT NULL DEFAULT '' COMMENT '姓名',
`age` INT NOT NULL DEFAULT 0 COMMENT '年龄',
`pos` VARCHAR(20) NOT NULL DEFAULT '' COMMENT '职位',
`add_time` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '添加时间'
)CHARSET utf8 COMMENT '员工记录表';

INSERT INTO staffs(`NAME`, `age`,`pos`,`add_time`) VALUES('23',22, 'manager',NOW());
INSERT INTO staffs(`NAME`, `age`,`pos`,`add_time`) VALUES('July',23, 'dev',NOW());
INSERT INTO staffs(`NAME`, `age`,`pos`,`add_time`) VALUES('2000',23, 'dev',NOW());

SELECT * FROM staffs;
ALTER TABLE staffs ADD INDEX idx_staffs_nameAgePos(`NAME`, `age`, `pos`);
```

## 索引规则

1. 全值匹配[个数+顺序]我最爱

```sql
SELECT * FROM staffs WHERE `NAME` = '23' AND age = 22 AND pos = 'manager';
```

2. 最佳左前缀法则

   - 如果索引了多列，要遵守最佳左前缀法则，指的是查询从索引的最左前列开始，并且不跳过索引中的列。

```sql
-- 索引有效
SELECT * FROM staffs WHERE name = '23';
-- 索引失效
SELECT * FROM staffs WHERE age = 22 AND pos = 'manager';
```

3. 不在索引列上做任何操作（计算，函数，[自动 or 手动]类型转换）,会导致索引失效而转向全表扫描。

```sql
-- 索引失效 left(n)函数 意思是取NAME的前n个字符
SELECT * FROM staffs WHERE left(NAME,4) = 'July';
```

4. 存储引擎不能使用索引中范围条件右边的列。

```sql
-- 索引失效
SELECT * FROM staffs WHERE NAME = 'July' AND age > 22 AND pos = 'manager';
```

5. 尽量使用覆盖索引（只访问索引的查询[索引列和查询列一致]），减少 select \* 的使用。

```sql
-- 效果更好： Extra Using Where,Using Index
SELECT NAME,age,pos FROM staffs WHERE NAME = 'July' AND age = 25 AND pos = 'dev';
-- 效果不好： Extra Using Where
SELECT * FROM staffs WHERE NAME = 'July' AND age = 25 AND pos = 'dev';
```

6. mysql 在使用不等于（!=或者<>）的时候无法使用索引会导致全表扫描。
7. is null, is not null 也无法使用索引。
8. like 以通配符开头（‘%abc...’），mysql 索引失效会变成全表扫描的操作。

```sql
-- 索引失效
SELECT * FROM staffs WHERE NAME LIKE '%July';
SELECT * FROM staffs WHERE NAME LIKE '%July%';
-- 索引有效 like 查询，一般在放到右边，来做查询
SELECT * FROM staffs WHERE NAME LIKE 'July%';
```

- 问题：如何解决 like '%字符串%' 时，索引不被使用的方法？

```sql
CREATE TABLE tbl_user (
`id` INT(11) NOT NULL AUTO_INCREMENT,
`NAME` VARCHAR(20) DEFAULT NULL,
`age` INT(11) DEFAULT NULL,
`email` VARCHAR(20) DEFAULT NULL,
PRIMARY KEY (id)
) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;

INSERT INTO tbl_user(NAME, age, email) VALUES('1aa1',21,'b@163.com');
INSERT INTO tbl_user(NAME, age,email) VALUES('2aa2',222,'a@163.com');
INSERT INTO tbl_user(NAME,age,email) VALUES('3aa3',265,'c@163.com');
INSERT INTO tbl_user(NAME,age,email) VALUES('4aa4',21,'d@163.com');

-- 创建索引
CREATE INDEX idx_tbl_user_nameAge ON tbl_user(NAME,age);

-- 索引失效
SELECT * FROM tbl_user WHERE NAME LIKE '%aa%';
SELECT email FROM tbl_user WHERE NAME LIKE '%aa%';

-- 索引有效: 使用 覆盖索引 的方法，使 %aa% 有效
SELECT age FROM tbl_user WHERE NAME LIKE '%aa%';
SELECT NAME,age FROM tbl_user WHERE NAME LIKE '%aa%';
SELECT id FROM tbl_user WHERE NAME LIKE '%aa%'; -- 主键索引

```

9. 字符串不加单引号，索引失效。

```sql
-- 不要在索引列上做任何数据转换（自动或隐式）
-- 索引失效
SELECT * FROM staffs WHERE NAME = 2000;
-- 索引有效
SELECT * FROM staffs WHERE NAME = '2000';
```

10. 少用 or, 用它来连接时会索引失效。

## 总结

全值匹配我最爱，最左前缀要遵守；
带头大哥不能死，中间兄弟不能断；
索引列上少计算，范围之后全失效；
LIKE 百分写最右，覆盖索引不写星；
不等空值还有 OR, 索引失效要少用；
