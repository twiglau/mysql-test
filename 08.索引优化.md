# 索引优化

```sql
CREATE TABLE staffs (
id INT PRIMARY KEY AUTO_INCREMENT,
NAME VARCHAR （24） NOT NULL DEFAULT '' COMMENT '姓名',
age INT NOT NULL DEFAULT 0 COMMENT '年龄',
pos VARCHAR (20) NOT NULL DEFAULT '' COMMENT '职位',
add_time TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '添加时间'
)CHARSET utf8 COMMENT '员工记录表';

INSERT INTO staffs(NAME, age,pos,add_time) VALUES('23',22, 'manager',NOW());
INSERT INTO staffs(NAME, age,pos,add_time) VALUES('July',23, 'dev',NOW());
INSERT INTO staffs(NAME, age,pos,add_time) VALUES('2000',23, 'dev',NOW());

SELECT * FROM staffs;
ALTER TABLE staffs ADD INDEX idx_staffs_nameAgePos(name, age, pos);
```

## 索引规则

1. 全值匹配[个数+顺序]我最爱

```sql
SELECT * FROM staffs WHERE name = '23' AND age = 22 AND pos = 'manager';
```

2. 最佳左前缀法则

   - 如果索引了多列，要遵守最佳左前缀法则，指的是查询从索引的最左前列开始，并且不跳过索引中的列。

   ```sql
   -- 索引有效
   SELECT * FROM staffs WHERE name = '23';
   -- 索引失效
   SELECT * FROM staffs WHERE age = 22 AND pos = 'manager';
   ```

3. 不在索引列上做任何操作（计算，函数，[自动 or 手动]类型转换）,会导致索引失效而转向全表扫描。

4. 存储引擎不能使用索引中范围条件右边的列。
5. 尽量使用覆盖索引（只访问索引的查询[索引列和查询列一致]），减少 select \* 的使用。
6. mysql 在使用不等于（!=或者<>）的时候无法使用索引会导致全表扫描。
7. is null, is not null 也无法使用索引。
8. like 以通配符开头（‘%abc...’），mysql 索引失效会变成全表扫描的操作。
9. 字符串不加单引号，索引失效。
10. 少用 or, 用它来连接时会索引失效。
