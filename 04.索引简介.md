# 索引

- 索引（Index）是帮助 MySQL 高效获取数据的数据结构. 索引是 数据结构；
- 索引的目的在于提高查询效率，可以类比字典；
  > 例如，如果要查“mysql"这个单词，我们肯定需要定位到“m"这个字母，然后在“m”这个字母下找到“ysql”这个单词。
  > 如果没有索引，那么可能需要 a ~ z, 如果我想找到 Java 开头的单词呢？ 或者 Oracle 开头的单词呢？
  > 如果没有索引，这个事情根本无法完成？

## 排好序的，快速查找数据结构

- 数据本身之外，数据库还维护着，一个满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据。
- 这样就可以在这些数据结构的基础上，实现高级查找算法。这种数据结构，就是索引。

  > 为了加快查找，可以维护一个右边所示的二叉查找树，每个节点分别包含 索引键值和一个指向对应数据记录物理
  > 地址的指针，这样就可以运用二叉查找在一定的复杂度内获取到相应数据，从而快速的检索出符合条件的记录。

- 结论

1. 一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。
2. 平常所说的索引，如果没有特别指明，都是指 B 树(多路搜索树，并不一定是 二叉的) 结构组织的索引。
   其中聚集索引，次要索引，覆盖索引，复合索引，前缀索引，唯一索引默认都是使用 B+树 索引，统称索引。
   当然，除了 B+树这种类型的索引之外，还有哈希索引(hash)

## 优势

- 类似大学图书馆建立的书目索引，提高数据检索的效率，降低数据库的 IO 成本
- 通过索引树对数据进行排序，降低数据排序的成本，降低了 CPU 的消耗

## 劣势

- 实际上索引也是一张表，该表保存了主键和索引字段，并指向实体表的记录，所以索引列也是要占用空间的；
- 虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行 INSERT,UPDATE 和 DELETE,因为更新表时，
  MySQL 不仅要保存数据，还要保存索引文件，每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后
  的索引信息。
- 索引只是提高效率的一个因素，如果你的 MySQL 有大数据量的表，就需要花时间研究建立最优秀的索引，或优化查询。

## mysql 索引分类

- 单值索引：即一个索引只包含单个列，一个表可以有多个单列索引
- 唯一索引：索引列的值必须唯一，单允许有空值
- 复合索引：即一个索引包含多个列；
- 基本语法

```sql
-- 创建
CREATE [UNIQUE] INDEX indexName ON mytable(columnname(length));
ALTER mytable ADD [UNIQUE] INDEX [indexName] on (columnname(length))

-- 删除
DROP INDEX [indexName] ON mytable;

-- 查看
SHOW INDEX FROM table_name\G
```

- 四种方式来添加数据表的索引：

```sql
--该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL.
ALTER TABLE tbl_name ADD PRIMARY KEY(cloumn_list)
--这条语句创建索引的值，必须是唯一的（除了NULL外，NULL可能会出现多次).
ALTER TABLE tbl_name ADD UNIQUE index_name(column_list)
--添加普通索引，索引值可出现多次。
ALTER TABLE tbl_name ADD INDEX index_name(column_list)
--该语句指定了索引为FULLTEXT,用于全文索引。
ALTER TABLE tbl_name ADD FULLTEXT index_name(column_list)
```

## mysql 索引结构

- BTree 索引
  > 真实的数据存在于叶子节点。
  > 非叶子节点，不存储真实的数据，只存储 指引搜索方向的数据项。如，17，35 并不真实存在于数据表中。

1. 如果要查找数据项 29，那么首先会把磁盘块 1，由磁盘加载到内存，此时发生一次 IO,在内存中用 二分查找确定 29 在 17 和 35 之间，锁定磁盘块 1 的 P2 指针，
   内存时间因为非常短（相比磁盘的 IO)可以忽略不计，通过磁盘块 1 的 P2 指针的磁盘地址把 磁盘块 3，由磁盘加载到内存，发生第二次 IO,29 在 26 和 30 之间，
   锁定磁盘块 3 的 P2 指针，通过指针加载磁盘块 8 到内存，发生第三次 IO,同时内存中做二分查找，找到 29，结束查询，总计三次 IO.
2. 真实的情况是，3 层的 b+树可以表示上百万的数据，如果上百万的数据查找只需要三次 IO,性能提供将是巨大的，如果没有索引，每个数据项都要发生一次 IO,
   那么总共需要百万次的 IO,显然成本非常高。

- Hash 索引
- full-text 全文索引
- R-Tree 索引

## 哪些情况需要创建索引

1. 主键自动建立唯一索引
2. 频繁作为查询条件的字段应该创建索引
3. 查询中与其它关联的字段，外键关系建立索引
4. 频繁更新的字段不适合创建索引：因为每次更新不单单是更新了记录还会更新索引
5. Where 条件里用不到的字段不创建索引
6. 单键/组合索引的选择问题：在高并发下倾向创建组合索引
7. 查询中排序的字段，排序字段若通过索引去访问，将大大提高排序速度
8. 查询中统计或者分组字段

## 哪些情况不要创建索引

理论上 300 万，MySQL 性能开始下降

1. 表记录太少
2. 经常增删改的表

- 提高了查询速度，同时却会降低更新表的速度，如对表进行 INSERT,UPDATE 和 DELETE.
  更新表时，MySQL 不仅要保存数据，还要保存一下索引文件。

3. 数据重复且分布平均的表字段，因此应该只为最经常查询和最经常排序的数据建立索引。
   注意，如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。

- 假如一个表有 10 万行记录，有一个字段 A 只有 T 和 F 两种值，且每个值的分布概率大约为 50%，那么对
  这种表 A 字段建立索引，一般不会提高数据库的查询速度。
- 索引的选择性是指索引列中不同值的数目与表中记录数的比。 如果一个表中有 2000 条记录，表索引列
  1980 个不同的值，那么这个索引的选择性就是 1980/2000=0.99. 一个索引的选择性越接近于 1，这个
  索引的效率就越高。
