# 案例

## 单表查询

```sql
CREATE TABLE IF NOT EXISTS 'article' (
'id' INT(10) UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT,
'author_id' INT(10) UNSIGNED NOT NULL,
'category_id' INT(10) UNSIGNED NOT NULL,
'views' INT (10) UNSIGNED NOT NULL,
'comments' INT(10) UNSIGNED NOT NULL,
'title' VARBINARY(255) NOT NULL,
'content' TEXT NOT NULL
);

INSERT INTO 'article'('author_id', 'category_id', 'views', 'comments', 'title', 'content') VALUES
(1, 1, 1, 1, 't1', 'c1'),
(2, 2, 2, 2, 't2', 'c2'),
(1, 1, 3, 3, 't3', 'c3');

SELECT * FROM article;
```

- 查询 category_id 为 1 且 comments 大于 1 的情况下，views 最多的 article_id;

```sql
SELECT id,author_id FROM article WHERE category_id = 1 AND comments > 1 ORDER BY views DESC LIMIT 1;
-- 结论：type 是 ALL, 即最坏的情况，Extra里还出现了 Using filesort，也是最坏的情况，优化是必须得；

-- 查询article表 索引；
show index from article;

-- 开始优化；
-- 1.1 新建索引 + 删除索引: 由于 comments > 1 是范围查找，把 索引打断了。
ALTER TABLE 'article' ADD INDEX idx_article_ccv('category_id', 'comments', 'views');
CREATE INDEX idx_article_ccv ON article(category_id, comments, views);
DROP INDEX idx_article_ccv ON article;

-- 结论：
-- 1. type 变成了range,这是可以忍受的，但是Extra里使用 Using filesort 仍然是无法接受的；
-- 2. 但是我们已经建立了索引，为啥没有用呢？
-- 3. 这是因为按照 BTree 索引的工作原理。
-- > 先排序 category_id,
-- > 如果遇到相同的 category_id,则再排序 comments, 如果遇到相同的 comments,则再排序 views;
-- > 当comments字段在联合索引里处于中间位置时，因 comments > 1 条件是一个范围值（所谓 range).
-- > MySQL无法利用索引，再对后面的views部分进行检索，即range类型查询字段后面的索引无效。


-- 1.2 优化：
CREATE INDEX idx_article_cv on article(category_id, views);

-- 结论： 可以看到， type 变为 ref, Extra里没有 Using filesort，说明已经优化成功了。
```

## 两表查询

```sql
CREATE TABLE IF NOT EXISTS 'class' (
"id" INT(10) UNSIGNED NOT NULL AUTO_INCREMENT.
"card" INT(10) UNSIGNED NOT NULL,
PRIMARY KEY ('id')
);
CREATE TABLE IF NOT EXISTS 'book' (
"bookid" INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,
"card" INT(10) UNSIGNED NOT NULL,
PRIMARY KEY ("bookid")
);
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));


INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
```

- 把 class 表的所有数据都列出来，如果不巧这本书（book）也有相同的 card，就把书的信息也一起列出来；如果没有对应的书，书的那部分就留空（NULL）

```sql
SELECT * FROM class LEFT JOIN book ON class.card = book.card;

-- 结论： type 有 ALL;

-- 开始优化：
-- 1.1 添加索引
ALTER TABLE book ADD INDEX idx_book_card('card');

-- 结论： 可以看到第二行的type 变为 ref,rows也变成了1，优化比较明显；
-- > 这是由左连接【左表全都有】特性决定的。LEFT JOIN 条件用于确定如何从右表搜索行，左边一定都有。
-- > 所以右边是我们的关键点，一定需要建立索引。
```
